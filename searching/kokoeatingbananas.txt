//brute
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int maxPile=0;
        for(int pile:piles){
            maxPile=Math.max(maxPile,pile);
        }
        for(int k=1;k<=maxPile;k++){
            if(canEat(piles,h,k)){
                return k;
            }
        }
        return maxPile;
    }
    private static boolean canEat(int[] piles,int h,int k){
        int hours=0;
        for(int pile:piles){
            hours+=(pile+k-1)/k;
        }
        return hours<=h;
    }
}
//optimal
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int maxPile=0;
        for(int pile:piles){
            maxPile=Math.max(maxPile,pile);
        }
        int low=1;
        int high=maxPile;
        int ans=0;
        while(low<=high){
            int mid=(low+high)/2;
            if(canEat(piles,h,mid)){
                ans=mid;
                high=mid-1;
            }else{
                low=mid+1;
            }
        }
        return ans;
    }
    private static boolean canEat(int[] piles,int h,int k){
        long hours=0;
        for(int pile:piles){
            hours+=(pile+k-1L)/k;
        }
        return hours<=h;
    }
}